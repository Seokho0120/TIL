## Hooks는 무엇일까?

함수형 컴포넌트에서도 **상태값(State)을 관리**할 수 있고, **생명주기 함수도 이용**할 수 있습니다. 훅을 사용하면 **재사용 가능한 로직**을 쉽게 만들 수 있고, 내장된 훅(useState, useEffect, useCallback)말고 **커스텀훅**을 만들 수 있습니다. 코드의 **가독성**도 좋아집니다.
<br>

사용조건 2가지가 있습니다. 첫번째로 **최상위에서 Hook을 호출(import)**해줘야 합니다. 두번째로 **함수형 컴포넌트에서만 사용 가능**합니다.(커스텀훅에서 사용 가능, 클래스형 컴포넌트에서 사용 불가능)

## useState

리액트에서 **컴포넌트의 동적인 값을 상태**라고 부른다. 이전에는 함수 컴포넌트에서는 state 사용이 불가능하였다. <br>
이후 react hooks의 useState 함수로 해결되었다. **useState는 state를 함수 컴포넌트 안에서 사용할 수 있게 해준다.**

## useEffect

렌더링과 무관한 로직이 렌더링 과정에서 실행되면, 렌더링에 영향을 줘서 기능상 악영향을 끼칠 수 있습니다. useEffect는 이러한 **side Effect를 렌더링 이후에 발생시킵니다.** 즉, **useEffect는 side Effect가 렌더링에 영향을 주지 않도록 설계하는 훅 입니다.**

### useEffect 사용법

useEffect에 **첫번째 인자는 함수**이고, **해당 함수 내에서 Side Effect를 실행**하면 된다. <br>
useEffect의 기본형은 전달된 함수를 3가지 조건에 실행시키는데, 렌더링이 완료된 직후, 새로운 props를 전달받았을 때, state값이 변경되었을 때 가 있다.

**두 번째 인자에 배열을 넣어 useEffect를 실행할 조건도 설정 가능**하다. <br>
**빈 배열**을 넣으면 컴포넌트가 **처음 생성될때만 useEffect가 실행**된다. <br>
**빈 배열에 state를 넣게되면** 지정한 **state값이 변경될때마다 useEffect가 실행**된다.

```javascript
import { useEffect } from "react"

// 사용법
useEffect( 실행시킬 동작, [ 타이밍 ] )

// 매 렌더링마다 Side Effect가 실행되어야 하는 경우
useEffect(() => {
  // Side Effect
})

// Side Effect가 첫 번째 렌더링 이후 한번 실행 되고,
// 이후 특정 값(value)의 업데이트를 감지했을 때마다 실행되어야 하는 경우
useEffect(() => {
  // Side Effect
}, [value])

// Side Effect가 첫 번째 렌더링 이후 한번 실행 되고,
// 이후 어떤 값의 업데이트도 감지하지 않도록 해야 하는 경우
useEffect(() => {
  // Side Effect
}, [])
```

### Side Effect

Side Effect는 일상생활의 맥락으로는 부정적인 의미로 사용되지만, 프로그래밍 측면에서는 단순히 부정적인 의미가 아닌 **부수 효과**로 표현할 수 있습니다. 함수 컴포넌트의 Side Effect는 **state와 props를 받아서 UI를 그려내는 것 이외의 행위**라고 할 수 있습니다. 즉, 렌더링이 아니고 **외부 세계에 영향을 주는 어떠한 행위** 입니다. <br>
대표적으로 **Data Fetching, DOM에 직접 접근(Event Lister), 구독(setInterval)**과 같은 행위들입니다. **이들은 모두 컴포넌트에서 꼭 필요한 Side Effect** 들 입니다. 그렇다고 함수의 body 자리에서 실행(render)시키면 안됩니다. 렌더링과 무관한 로직이 렌더링 과정에서 실행되면 렌더링 자체에 악영향을 줄 수 있기 때문입니다.

## useRef vs useState

**공통점**

- **함수형 컴포넌트에서 동적으로 상태관리**를 할 수 있게 해줍니다.

**차이점**

- useRef는 useState와 다르게 **state를 변화시킨 후 컴포넌트를 리렌더링하지 않습니다.**

**결론**
결론적으로 state의 렌더링 여부에 따라서, **렌더링이 필요한 경우 useState**를 사용하고 **렌더링이 필요하지 않을 경우 useRef**를 사용하면 됩니다.
**useRef는 순수 자바스크립트 객체를 생성하지만 동일한 참조 객체를 바라보고 있기 때문에 리렌더링이 일어나지 않는다가 포인트입니다.**
